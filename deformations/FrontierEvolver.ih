/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FrontierEvolver.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2012/03/01
 *
 * @brief Implementation of inline methods defined in FrontierEvolver.h
 *
 * This file is part of the DGtal library.
 */



//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::FrontierEvolver(const KSpace& aK, LImage& aI, DImage& aD, Surfel& aS, 
 const Functor& aF, const Predicate& aP, const double& aW)
  : myKSpace( aK ), myLImage( aI ), myDImage( aD ), mySurfel( aS ), 
    myFunctor( aF ), myPointPred( aP ), myW( aW ),
    myInnerLabel( myLImage( getInnerPoint( mySurfel ) ) ), 
    myOuterLabel( myLImage( getOuterPoint( mySurfel ) ) ), 
    mySurfelPred( myKSpace, myLImage, myInnerLabel, myOuterLabel ), 
    myFrontier( new Frontier ( myKSpace, mySurfelPred, 
			       SurfelAdjacency<KSpace::dimension>( true ), 
			       mySurfel ) )
{ 
  ASSERT( myW > 0 );   
  ASSERT( myW <= 1.0 ); 
  ASSERT( myKSpace.sIsSurfel( mySurfel ) );
  trace.info() << "Labels: " << myInnerLabel << " (inner region)" 
	       << " and " << myOuterLabel << " (outer region) " 
	       << std::endl;  
  ASSERT( myInnerLabel != myOuterLabel ); 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::~FrontierEvolver()
{
  delete( myFrontier ); 
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
double
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::update()
{
  trace.info() << "starting surfel: " << mySurfel << std::endl;  

  /// set of points that are candidate to the flip
  typedef std::vector<Point> Band;
  typedef typename Band::const_iterator BandIterator; 
  Band narrowBand; 
  init ( std::back_inserter( narrowBand ) ); 
  trace.info() << narrowBand.size() << " closest points" << std::endl; 

  /// velocity and zero-crossing time computation
  typedef std::pair<Point,double> PointTime; 
  typedef std::vector<PointTime> CandidateVector; 
  typedef typename CandidateVector::const_iterator CandidateIterator; 
  CandidateVector candidates; 
  
  typedef std::pair<Distance, Velocity> DistanceVelocity; 
  typedef std::vector<DistanceVelocity> DistanceVelocityVector;
  typedef typename DistanceVelocityVector::const_iterator DistanceVelocityIterator; 
  DistanceVelocityVector buffer; 

  double vmax = 0; 
  for ( BandIterator 
	 it = narrowBand.begin(), 
	 itEnd = narrowBand.end(); 
       it != itEnd; ++it)
    {
      // distance
      Distance d = myDImage( *it );
      // velocity
      Velocity v = myFunctor( *it );
      // maximal velocity
      double vabs = std::abs( static_cast<double>( v ) ); 
      if (vabs > vmax) vmax = vabs;
      // storing distance and velocity
      buffer.push_back( DistanceVelocity( d, v ) ); 
      // new candidate with its zero-crossing time
      if ( ( (d>=0) && (v<0) ) 
	   || ( (d<=0) && (v>0) ) )
	{ //if opposite signs (and v != 0)
	  double t = - static_cast<double>( d ) / v;
	  ASSERT( t >= 0 ); 
	  candidates.push_back( PointTime( *it, t ) ); 
	}
      // std::cout << d << " " << v << " " 
      // 		<< std::abs(d)/std::abs(v)
      // 		<< std::endl; 

    }
  trace.info() << candidates.size() << " candidates " << std::endl; 

  /// time threshold computation
  double tmax = myW / vmax; 
  trace.info() << "Distance max: " << myW << " / " 
	       << "Velocity max: " << vmax << " = " 
	       << "Time threshold: " << tmax << std::endl; 

  if (candidates.begin() != candidates.end())
    { //if they are candidates

      /// ordering of the points according 
      /// to their zero-crossing time
      trace.info() << "ordering..." << std::endl; 
      details::CompareSecondElement timeCompare; 
      std::sort( candidates.begin(), candidates.end(), timeCompare ); 
      trace.info() << "Times ranging from " 
		   << candidates.begin()->second 
		   << " to " 
		   << candidates.rbegin()->second 
		   << std::endl; 

      /// flip points one by one, in order,
      /// while possible
      unsigned int nbFlips = 0; 
      Point p = Point::diagonal(0), plast = Point::diagonal(0);
      double t = 0.0, tlast = 0.0;
      bool go = true;
      for (CandidateIterator 
	     it = candidates.begin(), 
	     itEnd = candidates.end(); 
	   ( (it != itEnd)&&(go) ); ++it)
	{
	  plast = p; 
	  p = it->first;
	  tlast = t; 
	  t = it->second; 
	  if (t <= tmax)
	    { 
	      const Label pLabel = myLImage(p); 
	      if ( myPointPred( p, pLabel ) )
		{ /// flip
		  nbFlips++; 
		  if ( pLabel == myInnerLabel )
		    {
		      ASSERT(myDImage(p) <= 0);  
		      std::cout << "i" ; 
		      myLImage.setValue( p, myOuterLabel );
		    }
		  else if ( pLabel == myOuterLabel )
		    {
		      ASSERT(myDImage(p) > 0);
		      std::cout << "o" ; 
		      myLImage.setValue( p, myInnerLabel ); 
		    }
		  else 
		    ASSERT( false && "impossible label in update method" ); 
		}
	    }
	  else 
	    go = false; 
	}
      std::cout << std::endl; 
      trace.info() << nbFlips << " flipped points in " << tlast << " unit time" << std::endl; 

      /// update distance map
      trace.info() << "updating signed distance function..." << std::endl; 

      if (tlast == 0.0) 
	tlast = tmax; 

      DistanceVelocityIterator itBuffer = buffer.begin(); 
      for (BandIterator 
	     it = narrowBand.begin(), 
	     itEnd = narrowBand.end(); 
	   it != itEnd; ++it, ++itBuffer)
	{
	  // velocity
	  DistanceVelocity pair( *itBuffer );  
	  Distance newDist = pair.first + tlast*pair.second; 
	  // correction due to the approximation error
	  if ( (newDist < 0.0001)&&(newDist > -0.0001) ) 
	    {
	      if (myLImage( *it ) == myInnerLabel) newDist = -0.0001; 
	      else newDist = 0.0001; 
	    }
	  //correction due to the non simplicity
	  //if not simple, ....

	  // set value
	  myDImage.setValue( *it, newDist );

	  // debug info
	  // std::cout << pair.first << " " << newDist << " " 
	  // 	    << pair.second << " " 
	  // 	    << std::abs(pair.first)/std::abs(pair.second)
	  // 	    << std::endl; 
	  ASSERT( ( (newDist <= 0)&&(myLImage( *it ) == myInnerLabel) ) 
		  || ( (newDist > 0)&&(myLImage( *it ) == myOuterLabel) ) );
	}

      /// update frontier if needed
      if (nbFlips > 0) 
	updateFrontier( plast ); 

      return tlast; 
    }
  else 
    return 0.0; 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
template <typename TOutputIterator>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::init( const TOutputIterator& out )
{

  TOutputIterator res = out; 

  /// set of points for which the distance value 
  /// is computed and stored in myDImage
  /////////////////////// TODO get the set type from a traits selector 
  /////////////////////// TODO store points as class member
  typedef DigitalSetFromMap<DImage> PointSet; 
  PointSet points(myDImage);
  //points.clear(); 

  /// initialization of the band from the 
  /// points adjacent to the frontier   
  unsigned int nbsurfels = 0;
  if (points.size() == 0)
    {//first step
      for ( SurfelIterator it = myFrontier->begin(), 
	      itEnd = myFrontier->end();
	    it != itEnd; ++it )
	{
	  Point in( getInnerPoint( *it ) ); 
	  ASSERT( myLImage(in) == myInnerLabel ); 
	  Point out( getOuterPoint( *it ) );
	  ASSERT( myLImage(out) == myOuterLabel ); 
	  //TODO using predicate on labels
	  if ( myDImage.domain().isInside( in ) ) 
	    {
	      insertAndAlwaysSetValue( myDImage, points, in, -0.5 );
	    }
	  if ( myDImage.domain().isInside( out ) )
	    {
	      insertAndAlwaysSetValue( myDImage, points, out, 0.5 );
	    }
	  ++nbsurfels;
	}
    }
  else 
    {//next steps

      //TODO think about the best way of dealing adjacentPoints
      //and copying it in the band
      typedef std::pair<const Point, Distance> PointDistance; 
      std::map<Point, Distance> adjacentPoints; 
      typedef typename std::map<Point, Distance>::iterator IteratorPointDistance; 

      for ( SurfelIterator it = myFrontier->begin(), 
	      itEnd = myFrontier->end();
	    it != itEnd; ++it )
	{
	  Point in( getInnerPoint( *it ) ); 
	  ASSERT( myLImage(in) == myInnerLabel ); 
	  Point out( getOuterPoint( *it ) );
	  ASSERT( myLImage(out) == myOuterLabel ); 
	  //TODO using predicate on labels myInnerLabel and myOuterLabel
	  bool flagIn = ( myDImage.domain().isInside( in ) ); 
	  bool flagOut = ( myDImage.domain().isInside( out ) ); 
	  if (flagIn && flagOut)
	    {
	      Distance din = myDImage( in ); 
	      ASSERT( din <= 0 ); 
	      Distance dout = myDImage( out );
	      ASSERT( dout > 0 );
 
	      // //TODO renormalize the distance values
	      Distance e = std::abs(din)+std::abs(dout);
	      Distance ndin = din/e; 
	      Distance ndout = dout/e; 
	      // Distance ndin = din; 
	      // Distance ndout = dout; 

	      std::pair<IteratorPointDistance, bool> rin 
		= adjacentPoints.insert( PointDistance( in, ndin ) );
	      if (rin.second == false) 
		{//if the same point is already stored
		  //take the minimal distance
		  if (std::abs(ndin) < std::abs(rin.first->second))
		    rin.first->second = ndin;
		}
	      std::pair<IteratorPointDistance, bool> rout 
		= adjacentPoints.insert( PointDistance( out, ndout ) );
	      if (rout.second == false) 
		{//if the same point is already stored
		  //take the minimal distance
		  if (std::abs(ndout) < std::abs(rout.first->second))
		    rout.first->second = ndout;
		}
	    }
	  else
	    {
	      if (flagIn)
	        {ASSERT(false && "not implemented yet");}
	      if (flagOut)
		{ASSERT(false && "not implemented yet");}
	    }
	  ++nbsurfels;
	}

      points.clear();
      for ( IteratorPointDistance 
	      it = adjacentPoints.begin(), 
	      itEnd = adjacentPoints.end();
	    it != itEnd; ++it )
	{
	  PointDistance pair( *it ); 
	  insertAndSetValue( myDImage, points, pair.first, pair.second );
	}
      trace.info() << adjacentPoints.size() << " adjacent points." << std::endl;  
      trace.info() << points.size() << " distinct adjacent points." << std::endl;  
    }

  trace.info() << nbsurfels << " surfels found." << std::endl;  
  std::copy( points.begin(), points.end(), res ); 

  ///////////// debug
  // for (typename PointSet::Iterator it = points.begin(), 
  // 	 itEnd = points.end(); it != itEnd; ++it)
  //   {
  //     Point neighbor = *it; 
  //     for (Dimension k = 0; k < Point::dimension; ++k)
  // 	{
  // 	  typename Point::Coordinate c = neighbor.at(k); 
  // 	  neighbor.at(k) = (c+1); 
  // 	  if ( points.find(neighbor) == points.end() ) 
  // 	    {
  // 	      unsigned int nb = 0, nbPos = 0; 
  // 	      Point neighbor2 = neighbor; 
  // 	      for (Dimension l = 0; l < Point::dimension; ++l)
  // 		{
  // 		  typename Point::Coordinate c = neighbor2.at(l); 
  // 		  neighbor2.at(l) = (c+1); 
  // 		  if ( points.find(neighbor2) != points.end() ) 
  // 		    {
  // 		      nb++; 
  // 		      std::cout << neighbor2 << myDImage( neighbor2 ) << std::endl; 
  // 		      if ( myDImage( neighbor2 )>=0 ) nbPos++; 
  // 		    } 
  // 		  neighbor2.at(l) = (c-1); 
  // 		  if ( points.find(neighbor2) != points.end() ) 
  // 		    {
  // 		      nb++; 
  // 		      std::cout << neighbor2 << myDImage( neighbor2 ) << std::endl; 
  // 		      if ( myDImage( neighbor2 )>=0 ) nbPos++; 
  // 		    } 
  // 		  neighbor2.at(l) = c; 
  // 		}
  // 	      std::cout << nbPos << " / " << nb << " / 6 " << std::endl;
  // 	      ASSERT( (nbPos == nb)||(nbPos == 0) ); 
  // 	    } 
  // 	  neighbor.at(k) = (c-1); 
  // 	  if ( points.find(neighbor) == points.end() ) 
  // 	    {
  // 	      unsigned int nb = 0, nbPos = 0; 
  // 	      Point neighbor2 = neighbor; 
  // 	      for (Dimension l = 0; l < Point::dimension; ++l)
  // 		{
  // 		  typename Point::Coordinate c = neighbor2.at(l); 
  // 		  neighbor2.at(l) = (c+1); 
  // 		  if ( points.find(neighbor2) != points.end() ) 
  // 		    {
  // 		      nb++; 
  // 		      std::cout << neighbor2 << myDImage( neighbor2 ) << std::endl; 
  // 		      if ( myDImage( neighbor2 )>=0 ) nbPos++; 
  // 		    } 
  // 		  neighbor2.at(l) = (c-1); 
  // 		  if ( points.find(neighbor2) != points.end() ) 
  // 		    {
  // 		      nb++; 
  // 		      std::cout << neighbor2 << myDImage( neighbor2 ) << std::endl; 
  // 		      if ( myDImage( neighbor2 )>=0 ) nbPos++; 
  // 		    } 
  // 		  neighbor2.at(l) = c; 
  // 		}
  // 	      std::cout << nbPos << " / " << nb << " / 6 " << std::endl;
  // 	      ASSERT( (nbPos == nb)||(nbPos == 0) ); 
  // 	    } 
 
  // 	  neighbor.at(k) = c; 
  // 	}
  //   }
  // trace.info() << "DT..." << std::endl;  
  ///////// end debug

  /// FMM 
  
  //definition
  typedef FMM<DImage, PointSet, typename DImage::Domain::Predicate > FMM;
  //TODO restreindre a deux labels
  FMM fmm( myDImage, points, myDImage.domain().predicate() );
  trace.info() << fmm << std::endl;  

  Point p = Point::diagonal(0);      //last point
  Distance d = 0;                  //its distance
  //first pass
  {
    double threshold = myW + 1;  // distance threshold
    while ( (fmm.computeOneStep( p, d )) 
	    && (std::abs(d) < threshold) )
      {
	ASSERT( myDImage(p) == d ); 
	ASSERT( ((myLImage(p) == myInnerLabel)&&(d<0))
		|| ((myLImage(p) == myOuterLabel)&&(d>0)) ); 
	*res++ = p; 
      }
    std::cout << std::endl; 
  }
  trace.info() << fmm << std::endl; 

  //second pass
  {
    double threshold = myW + 2;  // distance threshold
    while ( (fmm.computeOneStep( p, d )) 
	    && (std::abs(d) < threshold) )
      { }
  }
  trace.info() << fmm << std::endl; 

}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
typename TFunctor, typename TPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::selfDisplay ( std::ostream & out ) const
{
  out << "[FrontierEvolver]\n";
  out << "\n";
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
bool
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::isValid() const
{
    return true;
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, 
				TFunctor, TPredicate>::Point
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::getInnerPoint(const Surfel& s) const
{
  return myKSpace.sCoords( myKSpace.sDirectIncident( s, *myKSpace.sOrthDirs( s ) ) );
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, 
				TFunctor, TPredicate>::Point
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::getOuterPoint(const Surfel& s) const
{
  return myKSpace.sCoords( myKSpace.sIndirectIncident( s, *myKSpace.sOrthDirs( s ) ) ); 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TPredicate>
::updateFrontier(const Point& p)
{
  /// update mySurfel
  //neigbors
  // std::cout << p << myLImage(p) << " "; 
  // Point neighbor = p; 
  // for (Dimension k = 0; k < Point::dimension; ++k)
  //   {
  //     typename Point::Coordinate c = neighbor.at(k); 
  //     neighbor.at(k) = (c+1); 
  //     std::cout << neighbor << myLImage(neighbor) << " "; 
  //     neighbor.at(k) = (c-1); 
  //     std::cout << neighbor << myLImage(neighbor) << " "; 
  //     neighbor.at(k) = c; 
  //   }
  // std::cout << std::endl; 


  /// spel creation
  typename KSpace::SCell spel; 
  const Label pLabel = myLImage(p); 
  if ( pLabel == myInnerLabel )
    {
      ASSERT( (myDImage(p) <= 0) ); 
      spel = myKSpace.sSpel( p, KSpace::POS ); 
    }
  else if ( pLabel == myOuterLabel )
    {
      ASSERT( (myDImage(p) > 0) ); 
      spel = myKSpace.sSpel( p, KSpace::NEG );
    }
  else 
    ASSERT( false && "impossible label in updateFrontier method" ); 

  /// for each direction 
  bool flag = false; 
  for ( typename KSpace::DirIterator q = myKSpace.sDirs( spel ); 
  	( (q != 0)&&(!flag) ); ++q ) 
    { 
      const DGtal::Dimension dir = *q;

      /// for the direct orientation
      typename KSpace::SCell surfel 
  	= myKSpace.sDirectIncident( spel, dir );
      ASSERT( myKSpace.sIsSurfel( surfel ) ); 
      //      std::cerr << getInnerPoint( surfel ) << getOuterPoint( surfel ) << std::endl;   
      if ( mySurfelPred( surfel ) )
  	{
  	  mySurfel = surfel; 
  	  flag = true; 
  	}
      if (!flag)
  	{
  	  /// for the indirect orientation
  	  surfel = myKSpace.sIndirectIncident( spel, dir ); 
  	  ASSERT( myKSpace.sIsSurfel( surfel ) ); 
	  //	  std::cerr << getInnerPoint( surfel ) << getOuterPoint( surfel ) << std::endl;   
  	  if ( mySurfelPred( surfel ) )
  	    {
  	      mySurfel = surfel; 
  	      flag = true; 
  	    }
  	}
    } 
  //std::cerr << std::endl; 
  ASSERT( flag && "last flipped point must be a border point in updateFrontier method" ); 

  /// update frontier
  delete ( myFrontier ); 
  myFrontier = new Frontier ( myKSpace, mySurfelPred, 
			      SurfelAdjacency<KSpace::dimension>( true ), 
			      mySurfel ); 

}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TPredicate>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, 
		    TFunctor, TPredicate> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


