/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FrontierEvolver.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2012/03/01
 *
 * @brief Implementation of inline methods defined in FrontierEvolver.h
 *
 * This file is part of the DGtal library.
 */


#define WITHINFO

//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::FrontierEvolver(const KSpace& aK, LImage& aI, DImage& aD, const Surfel& aS, 
		  const Functor& aF, const TopoPredicate& aP, Partition* aPartitionPtr )
  : myKSpace( aK ), myLImage( aI ), myDImage( aD ), 
    myPointSet( SetFromImageSelector<DImage>::get( myDImage ) ), 
    mySurfel( aS ), myFunctor( aF ), myTopoPred( aP ), 
    myPartitionPtr( aPartitionPtr),
    myInnerLabel( myLImage( getInnerPoint( mySurfel ) ) ), 
    myOuterLabel( myLImage( getOuterPoint( mySurfel ) ) ), 
    mySurfelPred( myKSpace, myLImage, myInnerLabel, myOuterLabel ), 
    myFrontier( new Frontier ( myKSpace, mySurfelPred, 
			       SurfelAdjacency<KSpace::dimension>( true ), 
			       mySurfel ) )
{ 
  ASSERT( myFrontier ); 

  #ifdef WITHINFO
  trace.info() << "Labels: " << myInnerLabel << " (inner region)" 
	       << " and " << myOuterLabel << " (outer region) " 
	       << std::endl;  
  #endif
  ASSERT( myInnerLabel != myOuterLabel ); 
  ASSERT( myKSpace.sIsSurfel( mySurfel ) );
  ASSERT( mySurfelPred( mySurfel ) ); 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::~FrontierEvolver()
{
  delete( myFrontier ); 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>::Surfel
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::surfel() const
{
  return mySurfel;
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::setSurfel(const Surfel& aSurfel)
{
  /// update surfel
  mySurfel = aSurfel;

  ASSERT( myKSpace.sIsSurfel( mySurfel ) ); 
  ASSERT( mySurfelPred( mySurfel ) ); 
  ASSERT( myInnerLabel == myLImage( getInnerPoint( mySurfel ) ) );
  ASSERT( myOuterLabel == myLImage( getOuterPoint( mySurfel ) ) );  

  /// update frontier
  delete ( myFrontier ); 
  myFrontier = new Frontier ( myKSpace, mySurfelPred, 
			      SurfelAdjacency<KSpace::dimension>( true ), 
			      mySurfel ); 
  ASSERT( myFrontier );   
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::SurfelIterator
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::begin() const
{
  return myFrontier->begin();
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::SurfelIterator
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::end() const
{
  return myFrontier->end();
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
bool
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::isValid() const
{
  return ( ( myInnerLabel == myLImage( getInnerPoint( mySurfel ) ) )
	   && ( myOuterLabel == myLImage( getOuterPoint( mySurfel ) ) ) );   
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
typename TFunctor, typename TTopoPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::selfDisplay ( std::ostream & out ) const
{
  out << "[FrontierEvolver]\n";
  out << "\n";
}


///////////////////////////////////////////////////////////////////////////////
// ----------------------- Main methods ------------------------------


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
double
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::update(const double& aT)
{
  ASSERT( myKSpace.sIsSurfel( mySurfel ) ); 
  ASSERT( mySurfelPred( mySurfel ) ); 
  ASSERT( myInnerLabel == myLImage( getInnerPoint( mySurfel ) ) );
  ASSERT( myOuterLabel == myLImage( getOuterPoint( mySurfel ) ) );  

  #ifdef WITHINFO
  trace.info() << std::endl; 
  trace.info() << "starting surfel: " << mySurfel << std::endl;  
  trace.info() << "between: " << myInnerLabel << " (inner region)" 
	       << " and " << myOuterLabel << " (outer region) " 
	       << std::endl;  
  #endif

  /// narrow band
  typedef std::vector<Point> Band;
  Band narrowBand; 
  initNarrowBand ( std::back_inserter( narrowBand ) ); 
  #ifdef WITHINFO
  trace.info() << narrowBand.size() << " closest points" << std::endl; 
  #endif

  /// speed and zero-crossing time computation
  typedef std::vector<DistanceSpeed> DistanceSpeedVector;
  DistanceSpeedVector buffer; 
  /// candidates to flip
  typedef std::vector<PointTime> CandidateVector; 
  CandidateVector candidates; 
  initCandidates( narrowBand.begin(), narrowBand.end(), 
		  std::back_inserter( buffer ), 
		  std::back_inserter( candidates ) ); 
  #ifdef WITHINFO
  trace.info() << candidates.size() << " candidates " << std::endl; 
  #endif

  if (candidates.begin() != candidates.end())
    { //if there are candidates

      /// ordering of the points according 
      /// to their zero-crossing time
      #ifdef WITHINFO
      trace.info() << "ordering..." << std::endl;
      #endif
 
      details::CompareSecondElement timeCompare; 
      std::sort( candidates.begin(), candidates.end(), timeCompare ); 

      #ifdef WITHINFO
      trace.info() << "Times ranging from " 
		   << candidates.begin()->second 
		   << " to " 
		   << candidates.rbegin()->second 
		   << std::endl; 
      #endif

      /// flip points one by one, in order, while it is possible
      //points not allowed to flip because not simple
      std::set<Point> forbiddenPoints; 
      // last point and its zero-crossing time
      Point lastP = Point::diagonal(0);
      double lastT = 0.0;
      int nbFlips = updateLabelImage( candidates.begin(), candidates.end(), 
				      std::inserter( forbiddenPoints, forbiddenPoints.begin() ), 
				      lastP, lastT, aT ); 
      ASSERT( lastT <= aT ); 
      #ifdef WITHINFO
      trace.info() << nbFlips << " flipped points in " << lastT << " unit time" << std::endl; 
      #endif

      /// update distance map anyway
      #ifdef WITHINFO
      trace.info() << "updating signed distance function..." << std::endl; 
      #endif
      updateDistanceImage( narrowBand.begin(), narrowBand.end(), 
			   buffer.begin(), forbiddenPoints, aT ); 
 
      /// update frontier if needed
      if (nbFlips > 0) 
	updateFrontier( lastP ); 

      return aT; 
    }
  else 
    return 0.0; 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
template <typename TOutputIterator>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::initNarrowBand( TOutputIterator res )
{

  //predicate and FMM definitions
  typename Domain::Predicate pointPredicate = myDImage.domain().predicate(); 
  typedef FMM<DImage, PointSet, typename Domain::Predicate> FMM; 

  /// initialization of the band from the 
  /// points adjacent to the frontier   
  if (myPointSet.size() == 0)
    {//first step
      FMM::initFromBelsRange(myKSpace, myFrontier->begin(), myFrontier->end(), 
			myDImage, myPointSet, 0.5, true); 
    }
  else 
    {//next steps

      //this renormalization doesn ot work at all
      // FMM::initFromBelsRange(myKSpace, myFrontier->begin(), myFrontier->end(), 
      // 			     myDImage, myDImage, myPointSet, true); 
      //TODO think about the best way of dealing with adjacentPoints
      //and copying it in the band
      typedef std::pair<const Point, Distance> PointDistance; 
      std::map<Point, Distance> adjacentPoints; 
      typedef typename std::map<Point, Distance>::iterator IteratorPointDistance; 

      for ( SurfelIterator it = myFrontier->begin(), 
      	      itEnd = myFrontier->end();
      	    it != itEnd; ++it )
      	{
      	  Point in( getInnerPoint( *it ) ); 
      	  Point out( getOuterPoint( *it ) );

	  ASSERT( myLImage(in) == myInnerLabel ); 
	  Distance din = myDImage( in ); 
	  ASSERT( din <= 0 ); 

	  ASSERT( myLImage(out) == myOuterLabel ); 
	  Distance dout = myDImage( out );
	  ASSERT( dout > 0 );

	  std::pair<IteratorPointDistance, bool> rin 
	    = adjacentPoints.insert( PointDistance( in, din ) );

	  std::pair<IteratorPointDistance, bool> rout 
	    = adjacentPoints.insert( PointDistance( out, dout ) );
      	}

      myPointSet.clear();
      for ( IteratorPointDistance 
      	      it = adjacentPoints.begin(), 
      	      itEnd = adjacentPoints.end();
      	    it != itEnd; ++it )
      	{
      	  PointDistance pair( *it ); 
      	  insertAndSetValue( myDImage, myPointSet, pair.first, pair.second );
      	}
    }


  std::copy( myPointSet.begin(), myPointSet.end(), res ); 

  #ifdef WITHINFO
  trace.info() << myPointSet.size() << " distinct adjacent points." << std::endl;  
  #endif


  /// FMM computation
  FMM fmm( myDImage, myPointSet, pointPredicate );
  #ifdef WITHINFO
  trace.info() << fmm << std::endl;  
  #endif

  Point p = Point::diagonal(0);      //last point
  Distance d = 0;                  //its distance
  //first pass
  {
    double threshold = std::max( std::abs(fmm.max()),std::abs(fmm.min()) ) 
      + 2.0;  // distance threshold
    while ( (fmm.computeOneStep( p, d )) 
	    && (std::abs(d) < threshold) )
      {
	ASSERT( myDImage(p) == d ); 
        #ifdef WITHINFO
	if (! ( ((myLImage(p) == myInnerLabel)&&(d<0.0001))
		|| ((myLImage(p) == myOuterLabel)&&(d>-0.0001)) 
		|| ( (myLImage(p) != myInnerLabel)&&(myLImage(p) != myOuterLabel) ) ) )
	  {
	    trace.info() << p << " in " << myLImage(p) << " at " << d << std::endl; 
	  } 
	#endif

	ASSERT( ((myLImage(p) == myInnerLabel)&&(d<0.0001))
		|| ((myLImage(p) == myOuterLabel)&&(d>-0.0001)) 
		|| ( (myLImage(p) != myInnerLabel)&&(myLImage(p) != myOuterLabel) ) ); 
	*res++ = p; 
      }
  }
  #ifdef WITHINFO
  trace.info() << fmm << std::endl;  
  #endif

  //second pass
  {
    double threshold = std::max( std::abs(fmm.max()),std::abs(fmm.min()) ) 
      + 2.0;  // distance threshold
    while ( (fmm.computeOneStep( p, d )) 
	    && (std::abs(d) < threshold) )
      { }
  }
  #ifdef WITHINFO
  trace.info() << fmm << std::endl;  
  #endif

}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
template <typename TInputIterator, typename TOutputIterator1, typename TOutputIterator2>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::initCandidates( const TInputIterator& itb, const TInputIterator& ite, 
		  TOutputIterator1 aDistanceSpeedIto, TOutputIterator2 aCandidateIto )
{
  for ( TInputIterator it = itb; 
       it != ite; ++it)
    {
      // point
      Point p = *it; 
      // distance
      Distance d = myDImage( p );
      // speed
      Speed v = myFunctor( p );
      // storing distance and speed
      *aDistanceSpeedIto++ = DistanceSpeed( d, v ); 
      // new candidate with its zero-crossing time
      if ( ( myLImage( p ) == myInnerLabel ) 
	   || (myLImage( p ) == myOuterLabel ) )
	{
	  if ( ( (d>0) && (v<0) ) 
	       || ( (d<=0) && (v>0) ) )
	    { // if opposite signs (and v != 0)
	      double t = - static_cast<double>( d ) / v;
	      ASSERT( t >= 0 ); 
	      // storing candidate
	      *aCandidateIto++ = PointTime( p, t ); 
	    }
	}
    }
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
template <typename TInputIterator, typename TOutputIterator>
inline
int
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::updateLabelImage( const TInputIterator& itb, const TInputIterator& ite, TOutputIterator ito, 
		    Point& aP, double& aT, const double&  aTMax )
{

  unsigned int nbFlips = 0; 

  for (TInputIterator it = itb;
       ( (it != ite)&&(it->second <= aTMax) ); ++it)
    {
      aP = it->first;
      aT = it->second; 
      const Label label = myLImage( aP ); 
      const Label oppositeLabel = 
	(label == myInnerLabel)?myOuterLabel:myInnerLabel;
 
      if ( myTopoPred( aP, oppositeLabel ) )
	{ /// flip
	  checkPartition( aP ); 
        #ifdef WITHINFO
	  trace.emphase() << aP << " flipped into region " 
			  << oppositeLabel << std::endl;
        #endif
	  myLImage.setValue( aP, oppositeLabel ); 
	  ++nbFlips;
	}
      else 
	{
	  *ito++ = aP; 
        #ifdef WITHINFO
	  trace.emphase() << aP << " is not a simple point!" << std::endl;
        #endif
	}
    }

  return nbFlips; 
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::updateFrontier(const Point& p)
{
  /// spel creation
  typename KSpace::SCell spel; 
  const Label pLabel = myLImage(p); 
  if ( pLabel == myInnerLabel )
    {
      ASSERT( (myDImage(p) <= 0) ); 
      spel = myKSpace.sSpel( p, KSpace::POS ); 
    }
  else if ( pLabel == myOuterLabel )
    {
      ASSERT( (myDImage(p) > 0) ); 
      spel = myKSpace.sSpel( p, KSpace::NEG );
    }
  else 
    ASSERT( false && "impossible label in updateFrontier method" ); 

  /// for each direction 
  Surfel newSurfel; 
  bool flag = false; 
  for ( typename KSpace::DirIterator q = myKSpace.sDirs( spel ); 
  	( (q != 0)&&(!flag) ); ++q ) 
    { 
      const DGtal::Dimension dir = *q;

      /// for the direct orientation
      typename KSpace::SCell surfel 
  	= myKSpace.sDirectIncident( spel, dir );
      ASSERT( myKSpace.sIsSurfel( surfel ) ); 
      if ( mySurfelPred( surfel ) )
  	{
  	  newSurfel = surfel; 
  	  flag = true; 
  	}
      if (!flag)
  	{
  	  surfel = myKSpace.sIndirectIncident( spel, dir ); 
  	  ASSERT( myKSpace.sIsSurfel( surfel ) ); 
  	  if ( mySurfelPred( surfel ) )
  	    {
  	      newSurfel = surfel; 
  	      flag = true; 
  	    }
  	}
    } 
  ASSERT( flag && "last flipped point must be a border point in updateFrontier method" ); 

  this->setSurfel( newSurfel ); 

}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
template <typename TInputIterator1, typename TInputIterator2, typename TSet>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::updateDistanceImage( const TInputIterator1& itb, const TInputIterator1& ite,
		       TInputIterator2 aDistanceSpeedIt, 
		       const TSet& aSet, const double& t )
{
  for (TInputIterator1 it = itb; 
       it != ite; ++it, ++aDistanceSpeedIt)
    {
      // point
      const Point p = *it; 
      // distance and speed
      const DistanceSpeed pair( *aDistanceSpeedIt );  
      Distance newDist = pair.first + t * pair.second; 

      //label 
      const Label pLabel = myLImage( p ); 

      const Distance eps = std::numeric_limits<Distance>::epsilon();
      // correction due to the approximation error
      if ( ( (newDist < 0.0001)&&(newDist > -0.0001) )
	   //correction due to the non simplicity
	   || ( aSet.find( p ) != aSet.end() ) )
	{
	  if (pLabel == myInnerLabel) newDist = -eps; 
	  else newDist = eps; 
	}

    #ifdef WITHINFO
      if ( !( ( (newDist <= 0)&&(myLImage( p ) == myInnerLabel) ) 
	      || ( (newDist > 0)&&(myLImage( p ) == myOuterLabel) ) 
	      || ( (myLImage( p ) != myInnerLabel)&&(myLImage( p ) != myOuterLabel) ) ) )
	{
	  trace.info() << p << " in " << myLImage( p ) 
		       << " at " << newDist << std::endl; 
	}
    #endif

      ASSERT( ( (newDist <= 0)&&(myLImage( p ) == myInnerLabel) ) 
	      || ( (newDist > 0)&&(myLImage( p ) == myOuterLabel) ) 
	      || ( (myLImage( p ) != myInnerLabel)&&(myLImage( p ) != myOuterLabel) ) );


      // set value
      myDImage.setValue( p, newDist );

    }

}


///////////////////////////////////////////////////////////////////////////////
// ----------------------- Small Helpers ------------------------------
template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
void
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::checkPartition(const Point& aPoint)
{
  if (myPartitionPtr != NULL)
    {
      myPartitionPtr->checkFrontiers( this, aPoint ); 
    }
}


template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, 
				TFunctor, TTopoPredicate>::Point
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::getInnerPoint(const Surfel& s) const
{
  return myKSpace.sCoords( myKSpace.sDirectIncident( s, *myKSpace.sOrthDirs( s ) ) );
}

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
typename DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, 
				TFunctor, TTopoPredicate>::Point
DGtal::FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, TFunctor, TTopoPredicate>
::getOuterPoint(const Surfel& s) const
{
  return myKSpace.sCoords( myKSpace.sIndirectIncident( s, *myKSpace.sOrthDirs( s ) ) ); 
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TKSpace, typename TLabelImage, typename TDistanceImage, 
	  typename TFunctor, typename TTopoPredicate>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const FrontierEvolver<TKSpace, TLabelImage, TDistanceImage, 
		    TFunctor, TTopoPredicate> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


